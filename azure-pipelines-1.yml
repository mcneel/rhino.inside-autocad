trigger:
  branches:
    include:
      - master

pool:
  vmImage: 'windows-latest'

variables:
  buildPlatform: 'x64'
  solution: 'Rhino.Inside.AutoCAD.sln'
  GITHUB_REPO: 'mcneel/rhino.inside-autocad'
  installerProject: 'src/Rhino.Inside.AutoCAD.Installer/Rhino.Inside.AutoCAD.Installer.wixproj'

stages:
- stage: Build
  displayName: 'Build and Release'
  jobs:
  - job: Build
    displayName: 'Build'
    steps:
    - task: NuGetToolInstaller@1
      displayName: 'Install NuGet'
      inputs:
        versionSpec: '6.11.x'

    - task: UseDotNet@2
      displayName: 'Install .NET SDK 8.x'
      inputs:
        packageType: 'sdk'
        version: '8.0.x'

    # 0. EXTRACT VERSION
    - task: PowerShell@2
      displayName: 'Extract Version'
      inputs:
        targetType: 'inline'
        script: |
          $content = Get-Content "Directory.Build.props" -Raw
          if ($content -match '<AssemblyVersion>([^<]+)</AssemblyVersion>') {
            $version = $Matches[1].Trim()
            Write-Host "Version: $version"
            Write-Host "##vso[task.setvariable variable=AppVersion]$version"
          } else {
            Write-Error "Could not find AssemblyVersion in Directory.Build.props"
            exit 1
          }

    # 1. REMOVE INSTALLER PROJECT FROM SOLUTION
    - task: PowerShell@2
      displayName: 'Remove Installer Project from Solution'
      inputs:
        targetType: 'inline'
        script: |
          dotnet sln "$(solution)" remove "$(installerProject)"

    # 2. PUBLISH NET48
    - task: PowerShell@2
      displayName: 'Publish NET48 Projects'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Publishing GrasshopperLibrary for NET48..."
          dotnet publish "src/Rhino.Inside.AutoCAD.GrasshopperLibrary/Rhino.Inside.AutoCAD.GrasshopperLibrary.csproj" `
            --configuration Release `
            --framework net48 `
            --output "publish/net48" `
            /p:NoWarn=NU1605 `
            /p:CopyLocalLockFileAssemblies=true
          
          if ($LASTEXITCODE -ne 0) { exit 1 }

    # 3. PUBLISH NET8
    - task: PowerShell@2
      displayName: 'Publish NET8 Projects'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Publishing GrasshopperLibrary for NET8..."
          dotnet publish "src/Rhino.Inside.AutoCAD.GrasshopperLibrary/Rhino.Inside.AutoCAD.GrasshopperLibrary.csproj" `
            --configuration ReleaseNET8 `
            --framework net8.0-windows `
            --output "publish/net8" `
            --self-contained false `
            /p:NoWarn=NU1605 `
            /p:CopyLocalLockFileAssemblies=true
          
          if ($LASTEXITCODE -ne 0) { exit 1 }

    # 4. STAGE ALL FILES FOR WIX (including NuGet cache DLLs)
    - task: PowerShell@2
      displayName: 'Stage Files for Installer'
      inputs:
        targetType: 'inline'
        script: |
          $version = "$(AppVersion)"
          $stagePath = "D:\a\1\s\Deployment\OutputFiles\Rhino.Inside.AutoCAD.$version"
          $nugetCache = "$env:USERPROFILE\.nuget\packages"
          
          # DLLs to EXCLUDE
          $excludePattern = '^(RhinoCommon|RhinoWindows|Grasshopper|GH_IO|Eto\.|Acdbmgd|accoremgd|acmgd)'
          
          # Create Directory Structure
          New-Item -ItemType Directory -Force -Path "$stagePath\Icons\Large512" | Out-Null
          New-Item -ItemType Directory -Force -Path "$stagePath\Icons\Small32" | Out-Null
          New-Item -ItemType Directory -Force -Path "$stagePath\Toolbar" | Out-Null
          New-Item -ItemType Directory -Force -Path "$stagePath\Resources" | Out-Null
          New-Item -ItemType Directory -Force -Path "$stagePath\$version\Win64\NET48" | Out-Null
          New-Item -ItemType Directory -Force -Path "$stagePath\$version\Win64\NET8" | Out-Null

          # Copy Assets
          Copy-Item "src/Rhino.Inside.AutoCAD.Installer/Icons/*" "$stagePath\Icons\" -Recurse -Force -ErrorAction SilentlyContinue
          Copy-Item "src/Rhino.Inside.AutoCAD.Installer/Toolbar/*" "$stagePath\Toolbar\" -Force -ErrorAction SilentlyContinue
          Copy-Item "src/Rhino.Inside.AutoCAD.Installer/PackageContents.xml" "$stagePath\" -Force -ErrorAction SilentlyContinue
          Copy-Item "src/Rhino.Inside.AutoCAD.Installer/Resources/*" "$stagePath\Resources\" -Force -ErrorAction SilentlyContinue

          # Copy NET48 DLLs from publish
          Write-Host "Copying NET48 DLLs from publish..."
          Get-ChildItem "publish/net48/*.dll" | Where-Object { $_.Name -notmatch $excludePattern } | ForEach-Object {
            Copy-Item $_.FullName "$stagePath\$version\Win64\NET48\" -Force
          }

          # Copy NET8 DLLs from publish
          Write-Host "Copying NET8 DLLs from publish..."
          Get-ChildItem "publish/net8/*.dll" | Where-Object { $_.Name -notmatch $excludePattern } | ForEach-Object {
            Copy-Item $_.FullName "$stagePath\$version\Win64\NET8\" -Force
          }

          # Required DLLs that may be missing (transitive deps) - search NuGet cache
          $requiredDlls = @(
            @{Name="System.Collections.Immutable.dll"; Package="system.collections.immutable"; Framework="net48"},
            @{Name="System.Reflection.Metadata.dll"; Package="system.reflection.metadata"; Framework="net48"},
            @{Name="Microsoft.Bcl.HashCode.dll"; Package="microsoft.bcl.hashcode"; Framework="net48"},
            @{Name="System.Formats.Nrbf.dll"; Package="system.formats.nrbf"; Framework="net48"},
            @{Name="System.ComponentModel.Annotations.dll"; Package="system.componentmodel.annotations"; Framework="net48"},
            @{Name="CommunityToolkit.Mvvm.dll"; Package="communitytoolkit.mvvm"; Framework="net48"},
            @{Name="Serilog.Settings.Configuration.dll"; Package="serilog.settings.configuration"; Framework="net48"},
            @{Name="Serilog.Sinks.File.dll"; Package="serilog.sinks.file"; Framework="net48"},
            @{Name="Microsoft.Extensions.Configuration.dll"; Package="microsoft.extensions.configuration"; Framework="net48"},
            @{Name="Microsoft.Extensions.Configuration.Abstractions.dll"; Package="microsoft.extensions.configuration.abstractions"; Framework="net48"},
            @{Name="Microsoft.Extensions.Configuration.Binder.dll"; Package="microsoft.extensions.configuration.binder"; Framework="net48"},
            @{Name="Microsoft.Extensions.Configuration.FileExtensions.dll"; Package="microsoft.extensions.configuration.fileextensions"; Framework="net48"},
            @{Name="Microsoft.Extensions.Configuration.Json.dll"; Package="microsoft.extensions.configuration.json"; Framework="net48"},
            @{Name="Microsoft.Extensions.DependencyModel.dll"; Package="microsoft.extensions.dependencymodel"; Framework="net48"},
            @{Name="Microsoft.Extensions.FileProviders.Abstractions.dll"; Package="microsoft.extensions.fileproviders.abstractions"; Framework="net48"},
            @{Name="Microsoft.Extensions.FileProviders.Physical.dll"; Package="microsoft.extensions.fileproviders.physical"; Framework="net48"},
            @{Name="Microsoft.Extensions.FileSystemGlobbing.dll"; Package="microsoft.extensions.filesystemglobbing"; Framework="net48"},
            @{Name="Microsoft.Extensions.Primitives.dll"; Package="microsoft.extensions.primitives"; Framework="net48"}
          )

          Write-Host "`nSearching NuGet cache for missing DLLs..."
          foreach ($dll in $requiredDlls) {
            $net48Dest = "$stagePath\$version\Win64\NET48\$($dll.Name)"
            $net8Dest = "$stagePath\$version\Win64\NET8\$($dll.Name)"
            
            # Skip if already exists
            if ((Test-Path $net48Dest) -and (Test-Path $net8Dest)) {
              Write-Host "  Already have: $($dll.Name)"
              continue
            }
            
            # Search NuGet cache
            $packagePath = Join-Path $nugetCache $dll.Package
            if (Test-Path $packagePath) {
              # Find the DLL - prefer netstandard2.0, net48, or lib folder
              $found = Get-ChildItem -Path $packagePath -Recurse -Filter $dll.Name -ErrorAction SilentlyContinue | 
                Where-Object { $_.FullName -match '(netstandard2\.|net4|lib[\\/])' } |
                Select-Object -First 1
              
              if ($found) {
                if (-not (Test-Path $net48Dest)) {
                  Copy-Item $found.FullName $net48Dest -Force
                  Write-Host "  NET48: Copied $($dll.Name) from NuGet cache"
                }
                if (-not (Test-Path $net8Dest)) {
                  # For NET8, try to find net8/net6/netstandard version
                  $net8Found = Get-ChildItem -Path $packagePath -Recurse -Filter $dll.Name -ErrorAction SilentlyContinue | 
                    Where-Object { $_.FullName -match '(net8|net6|netstandard2\.)' } |
                    Select-Object -First 1
                  if ($net8Found) {
                    Copy-Item $net8Found.FullName $net8Dest -Force
                    Write-Host "  NET8: Copied $($dll.Name) from NuGet cache"
                  }
                }
              } else {
                Write-Host "  WARNING: $($dll.Name) not found in $packagePath" -ForegroundColor Yellow
              }
            } else {
              Write-Host "  WARNING: Package $($dll.Package) not in NuGet cache" -ForegroundColor Yellow
            }
          }

          # Final count
          Write-Host "`n=== Final DLL counts ==="
          Write-Host "NET48: $((@(Get-ChildItem "$stagePath\$version\Win64\NET48\*.dll")).Count) DLLs"
          Write-Host "NET8: $((@(Get-ChildItem "$stagePath\$version\Win64\NET8\*.dll")).Count) DLLs"
          
          Write-Host "`nNET48 DLLs:"
          Get-ChildItem "$stagePath\$version\Win64\NET48\*.dll" | ForEach-Object { Write-Host "  - $($_.Name)" }
          Write-Host "`nNET8 DLLs:"
          Get-ChildItem "$stagePath\$version\Win64\NET8\*.dll" | ForEach-Object { Write-Host "  - $($_.Name)" }

    # 5. ADD INSTALLER PROJECT BACK TO SOLUTION
    - task: PowerShell@2
      displayName: 'Add Installer Project back to Solution'
      inputs:
        targetType: 'inline'
        script: |
          dotnet sln "$(solution)" add "$(installerProject)"

    # 6. BUILD INSTALLER ONLY
    - task: VSBuild@1
      displayName: 'Build Installer'
      inputs:
        solution: '$(installerProject)'
        platform: '$(buildPlatform)'
        configuration: 'ReleaseNET8'
        msbuildArchitecture: 'x64'
        msbuildArgs: '/restore /m'

    # 7. COPY MSI TO STAGING
    - task: CopyFiles@2
      displayName: 'Copy MSI to Staging'
      inputs:
        SourceFolder: 'src/Rhino.Inside.AutoCAD.Installer/bin/x64/ReleaseNET8/en-US'
        Contents: '**.msi'
        TargetFolder: '$(Build.ArtifactStagingDirectory)'
        flattenFolders: true

    - task: PublishBuildArtifacts@1
      displayName: 'Publish MSI Artifact'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'installer'

    # 8. GITHUB RELEASE
    - task: PowerShell@2
      displayName: 'Create GitHub Release'
      inputs:
        targetType: 'inline'
        script: |
          $version = "$(AppVersion)"
          $msiFile = Get-ChildItem "$(Build.ArtifactStagingDirectory)/*.msi" | Select-Object -First 1
          if (-not $msiFile) { throw "MSI not found!" }
          
          $headers = @{"Authorization" = "token $(GITHUB_PAT)"; "Accept" = "application/vnd.github.v3+json"}
          $releaseBody = @{
            tag_name = "v$version"
            target_commitish = "master"
            name = "Release v$version"
            body = "Automated build $(Build.BuildId)"
          } | ConvertTo-Json
          
          $release = Invoke-RestMethod -Uri "https://api.github.com/repos/$(GITHUB_REPO)/releases" -Headers $headers -Method Post -Body $releaseBody -ContentType "application/json"
          $uploadUri = ($release.upload_url -replace '\{\?name,label\}', '') + "?name=$([Uri]::EscapeDataString($msiFile.Name))"
          
          Invoke-RestMethod -Uri $uploadUri -Headers @{"Authorization" = "token $(GITHUB_PAT)"; "Content-Type" = "application/octet-stream"} -Method Post -InFile $msiFile.FullName