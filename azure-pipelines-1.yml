trigger:
  branches:
    include:
      - master

pool:
  vmImage: 'windows-latest'

variables:
  buildPlatform: 'x64'
  solution: 'Rhino.Inside.AutoCAD.sln'
  GITHUB_REPO: 'mcneel/rhino.inside-autocad'
  installerProject: 'src/Rhino.Inside.AutoCAD.Installer/Rhino.Inside.AutoCAD.Installer.wixproj'

stages:
- stage: Build
  displayName: 'Build and Release'
  jobs:
  - job: Build
    displayName: 'Build'
    steps:
    - task: NuGetToolInstaller@1
      displayName: 'Install NuGet'
      inputs:
        versionSpec: '6.11.x'

    - task: UseDotNet@2
      displayName: 'Install .NET SDK 8.x'
      inputs:
        packageType: 'sdk'
        version: '8.0.x'

    # 0. EXTRACT VERSION
    - task: PowerShell@2
      displayName: 'Extract Version'
      inputs:
        targetType: 'inline'
        script: |
          $content = Get-Content "Directory.Build.props" -Raw
          if ($content -match '<AssemblyVersion>([^<]+)</AssemblyVersion>') {
            $version = $Matches[1].Trim()
            Write-Host "Version: $version"
            Write-Host "##vso[task.setvariable variable=AppVersion]$version"
          } else {
            Write-Error "Could not find AssemblyVersion in Directory.Build.props"
            exit 1
          }

    # 1. REMOVE INSTALLER PROJECT FROM SOLUTION
    - task: PowerShell@2
      displayName: 'Remove Installer Project from Solution'
      inputs:
        targetType: 'inline'
        script: |
          dotnet sln "$(solution)" remove "$(installerProject)"

    # 2. DOWNLOAD MISSING NUGET PACKAGES
    - task: PowerShell@2
      displayName: 'Download Required NuGet Packages'
      inputs:
        targetType: 'inline'
        script: |
          $nugetCache = "$env:USERPROFILE\.nuget\packages"
          
          $packages = @(
            "System.Collections.Immutable:8.0.0",
            "System.Reflection.Metadata:8.0.0",
            "Microsoft.Bcl.HashCode:1.1.1",
            "System.Formats.Nrbf:9.0.0",
            "System.IO.Pipelines:8.0.0",
            "System.Resources.Extensions:8.0.0",
            "System.Text.Encodings.Web:8.0.0",
            "System.Text.Json:8.0.0"
          )
          
          foreach ($pkg in $packages) {
            $parts = $pkg -split ":"
            $name = $parts[0]
            $version = $parts[1]
            
            Write-Host "Installing $name $version..."
            nuget install $name -Version $version -OutputDirectory "$nugetCache\_temp" -NonInteractive
          }
          
          Get-ChildItem "$nugetCache\_temp" -Directory | ForEach-Object {
            $pkgName = $_.Name -replace '\.\d+\.\d+\.\d+.*$', ''
            $destPath = Join-Path $nugetCache $pkgName.ToLower()
            if (-not (Test-Path $destPath)) {
              New-Item -ItemType Directory -Path $destPath -Force | Out-Null
            }
            $versionFolder = $_.Name -replace "^$([regex]::Escape($pkgName))\.", ''
            Move-Item $_.FullName (Join-Path $destPath $versionFolder) -Force -ErrorAction SilentlyContinue
          }

    # 3. PUBLISH NET48
    - task: PowerShell@2
      displayName: 'Publish NET48 Projects'
      inputs:
        targetType: 'inline'
        script: |
          dotnet publish "src/Rhino.Inside.AutoCAD.GrasshopperLibrary/Rhino.Inside.AutoCAD.GrasshopperLibrary.csproj" `
            --configuration Release --framework net48 --output "publish/net48" `
            /p:NoWarn=NU1605 /p:CopyLocalLockFileAssemblies=true
          if ($LASTEXITCODE -ne 0) { exit 1 }

    # 4. PUBLISH NET8
    - task: PowerShell@2
      displayName: 'Publish NET8 Projects'
      inputs:
        targetType: 'inline'
        script: |
          dotnet publish "src/Rhino.Inside.AutoCAD.GrasshopperLibrary/Rhino.Inside.AutoCAD.GrasshopperLibrary.csproj" `
            --configuration ReleaseNET8 --framework net8.0-windows --output "publish/net8" `
            --self-contained false /p:NoWarn=NU1605 /p:CopyLocalLockFileAssemblies=true
          if ($LASTEXITCODE -ne 0) { exit 1 }

    # 5. STAGE ALL FILES FOR WIX
    - task: PowerShell@2
      displayName: 'Stage Files for Installer'
      inputs:
        targetType: 'inline'
        script: |
          $version = "$(AppVersion)"
          $stagePath = "D:\a\1\s\Deployment\OutputFiles\Rhino.Inside.AutoCAD.$version"
          $nugetCache = "$env:USERPROFILE\.nuget\packages"
          $excludePattern = '^(RhinoCommon|RhinoWindows|Grasshopper|GH_IO|Eto\.|Acdbmgd|accoremgd|acmgd)'
          
          # Create Directory Structure
          New-Item -ItemType Directory -Force -Path "$stagePath\Icons\Large512" | Out-Null
          New-Item -ItemType Directory -Force -Path "$stagePath\Icons\Small32" | Out-Null
          New-Item -ItemType Directory -Force -Path "$stagePath\Toolbar" | Out-Null
          New-Item -ItemType Directory -Force -Path "$stagePath\Resources" | Out-Null
          New-Item -ItemType Directory -Force -Path "$stagePath\$version\Win64\NET48" | Out-Null
          New-Item -ItemType Directory -Force -Path "$stagePath\$version\Win64\NET8" | Out-Null

          # Copy Assets
          Copy-Item "src/Rhino.Inside.AutoCAD.Installer/Icons/*" "$stagePath\Icons\" -Recurse -Force -ErrorAction SilentlyContinue
          Copy-Item "src/Rhino.Inside.AutoCAD.Installer/Toolbar/*" "$stagePath\Toolbar\" -Force -ErrorAction SilentlyContinue
          Copy-Item "src/Rhino.Inside.AutoCAD.Installer/PackageContents.xml" "$stagePath\" -Force -ErrorAction SilentlyContinue
          Copy-Item "src/Rhino.Inside.AutoCAD.Installer/Resources/*" "$stagePath\Resources\" -Force -ErrorAction SilentlyContinue

          # Copy DLLs from publish
          Get-ChildItem "publish/net48/*.dll" | Where-Object { $_.Name -notmatch $excludePattern } | ForEach-Object {
            Copy-Item $_.FullName "$stagePath\$version\Win64\NET48\" -Force
          }
          Get-ChildItem "publish/net8/*.dll" | Where-Object { $_.Name -notmatch $excludePattern } | ForEach-Object {
            Copy-Item $_.FullName "$stagePath\$version\Win64\NET8\" -Force
          }

          # Copy missing DLLs from NuGet cache
          function Copy-FromNuGet($DllName, $PackageName, $DestNet48, $DestNet8) {
            $packagePath = Join-Path $nugetCache $PackageName.ToLower()
            if (-not (Test-Path $packagePath)) { return }
            
            if (-not (Test-Path $DestNet48)) {
              $dll = Get-ChildItem -Path $packagePath -Recurse -Filter $DllName -EA SilentlyContinue | 
                Where-Object { $_.FullName -match '(netstandard2\.0|net4)' } | Select-Object -First 1
              if ($dll) { Copy-Item $dll.FullName $DestNet48 -Force }
            }
            if (-not (Test-Path $DestNet8)) {
              $dll = Get-ChildItem -Path $packagePath -Recurse -Filter $DllName -EA SilentlyContinue | 
                Where-Object { $_.FullName -match '(net8|net7|net6|netstandard2\.)' } | Select-Object -First 1
              if ($dll) { Copy-Item $dll.FullName $DestNet8 -Force }
            }
          }

          $requiredFromNuGet = @{
            "System.Collections.Immutable.dll" = "system.collections.immutable"
            "System.Reflection.Metadata.dll" = "system.reflection.metadata"
            "Microsoft.Bcl.HashCode.dll" = "microsoft.bcl.hashcode"
            "System.Formats.Nrbf.dll" = "system.formats.nrbf"
            "System.ComponentModel.Annotations.dll" = "system.componentmodel.annotations"
            "System.IO.Pipelines.dll" = "system.io.pipelines"
            "System.Resources.Extensions.dll" = "system.resources.extensions"
            "System.Text.Encodings.Web.dll" = "system.text.encodings.web"
            "System.Text.Json.dll" = "system.text.json"
          }

          foreach ($entry in $requiredFromNuGet.GetEnumerator()) {
            Copy-FromNuGet $entry.Key $entry.Value "$stagePath\$version\Win64\NET48\$($entry.Key)" "$stagePath\$version\Win64\NET8\$($entry.Key)"
          }

          Write-Host "NET48: $((@(Get-ChildItem "$stagePath\$version\Win64\NET48\*.dll")).Count) DLLs"
          Write-Host "NET8: $((@(Get-ChildItem "$stagePath\$version\Win64\NET8\*.dll")).Count) DLLs"

    # 6. ADD INSTALLER PROJECT BACK TO SOLUTION
    - task: PowerShell@2
      displayName: 'Add Installer Project back to Solution'
      inputs:
        targetType: 'inline'
        script: |
          dotnet sln "$(solution)" add "$(installerProject)"

    # 7. BUILD INSTALLER ONLY
    - task: VSBuild@1
      displayName: 'Build Installer'
      inputs:
        solution: '$(installerProject)'
        platform: '$(buildPlatform)'
        configuration: 'ReleaseNET8'
        msbuildArchitecture: 'x64'
        msbuildArgs: '/restore /m'

    # 8. COPY MSI TO STAGING
    - task: CopyFiles@2
      displayName: 'Copy MSI to Staging'
      inputs:
        SourceFolder: 'src/Rhino.Inside.AutoCAD.Installer/bin/x64/ReleaseNET8/en-US'
        Contents: '**.msi'
        TargetFolder: '$(Build.ArtifactStagingDirectory)'
        flattenFolders: true

    # 8.1 RENAME MSI TO REMOVE SPACES BEFORE SIGNING
    - task: PowerShell@2
      displayName: 'Rename MSI for Signing'
      inputs:
        targetType: 'inline'
        script: |
          $msi = Get-ChildItem "$(Build.ArtifactStagingDirectory)/*.msi" | Select-Object -First 1
          $newName = $msi.Name -replace ' ', '_'
          Write-Host "##vso[task.setvariable variable=OriginalMsiName]$($msi.Name)"
          Write-Host "##vso[task.setvariable variable=RenamedMsiName]$newName"
          Rename-Item $msi.FullName $newName
          Write-Host "Renamed '$($msi.Name)' to '$newName'"

    # 8.2 SIGN MSI WITH AZURE TRUSTED SIGNING
    - task: TrustedSigning@0
      displayName: 'Sign MSI with Trusted Signing'
      inputs:
        Endpoint: $(AZURE_ENDPOINT)
        TrustedSigningAccountName: $(AZURE_CODE_SIGNING_NAME)
        CertificateProfileName: $(AZURE_CERT_PROFILE_NAME)
        FilesFolder: $(Build.ArtifactStagingDirectory)
        FilesFolderFilter: msi
      env:
        AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
        AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)
        AZURE_TENANT_ID: $(AZURE_TENANT_ID)

    # 8.3 RESTORE ORIGINAL MSI NAME
    - task: PowerShell@2
      displayName: 'Restore MSI Name'
      inputs:
        targetType: 'inline'
        script: |
          $msi = Join-Path "$(Build.ArtifactStagingDirectory)" "$(RenamedMsiName)"
          Rename-Item $msi "$(OriginalMsiName)"
          Write-Host "Restored '$(RenamedMsiName)' to '$(OriginalMsiName)'"

    - task: PublishBuildArtifacts@1
      displayName: 'Publish MSI Artifact'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'installer'

    # 9. GITHUB RELEASE (your working script)
    - task: PowerShell@2
      displayName: 'Create GitHub Release'
      inputs:
        targetType: 'inline'
        script: |
          # Find the MSI and extract version from filename
          $msiFile = Get-ChildItem "$(Build.ArtifactStagingDirectory)/*.msi" | Select-Object -First 1
          $msiName = $msiFile.Name
          
          # Extract version (e.g., "V1.0.0" from "Rhino.Inside.AutoCAD Installer NET8 V1.0.0.msi")
          if ($msiName -match 'V(\d+\.\d+\.\d+)') {
            $version = "v$($Matches[1])"
          } else {
            $version = "v$(Get-Date -Format 'yyyy.MM.dd')-build$(Build.BuildId)"
          }
          
          Write-Host "Creating release: $version"
          Write-Host "MSI file: $msiName"
          
          $headers = @{
            "Authorization" = "token $(GITHUB_PAT)"
            "Accept" = "application/vnd.github.v3+json"
          }
          
          # Check if release already exists
          $existingRelease = $null
          try {
            $existingRelease = Invoke-RestMethod -Uri "https://api.github.com/repos/$(GITHUB_REPO)/releases/tags/$version" -Headers $headers -Method Get
            Write-Host "Release $version already exists, deleting it..."
            Invoke-RestMethod -Uri "https://api.github.com/repos/$(GITHUB_REPO)/releases/$($existingRelease.id)" -Headers $headers -Method Delete
          } catch {
            Write-Host "No existing release found for $version"
          }
          
          # Create the release
          $releaseBody = @{
            tag_name = $version
            target_commitish = "main"
            name = "Release $version"
            body = "Automated release from Azure DevOps build $(Build.BuildId)"
            draft = $false
            prerelease = $false
          } | ConvertTo-Json
          
          $release = Invoke-RestMethod -Uri "https://api.github.com/repos/$(GITHUB_REPO)/releases" -Headers $headers -Method Post -Body $releaseBody -ContentType "application/json"
          
          Write-Host "Release created with ID: $($release.id)"
          
          # Upload the MSI
          $uploadUrl = $release.upload_url -replace '\{\?name,label\}', ''
          $uploadHeaders = @{
            "Authorization" = "token $(GITHUB_PAT)"
            "Content-Type" = "application/octet-stream"
          }
          
          $uploadUri = "$uploadUrl`?name=$([Uri]::EscapeDataString($msiName))"
          Write-Host "Uploading to: $uploadUri"
          
          Invoke-RestMethod -Uri $uploadUri -Headers $uploadHeaders -Method Post -InFile $msiFile.FullName
          
          Write-Host "MSI uploaded successfully!"